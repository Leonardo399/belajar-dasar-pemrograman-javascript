# Struktur Data red
! Pada modul ini kita akan membahas tentang tipe data JavaScript yang dapat menyimpan struktur data yang lebih kompleks. Beberapa jenis struktur data yang akan kita pelajari, antara lain:
	- Object
	- Array
	- Map
	- Set

## Object 
! Untuk menetapkan objek pada sebuah variabel kita gunakan tanda kurung kurawal {}.
// contoh : 
	let object = {key1: "value1", key2: "value2", key3: "value3"}

// cara mengakses property pada object
	- namaObj.namaProperty;
	- myobj.name;
	- myobj["my name"]; 
	! usahakan jangan memakai namaProperty dengan spasi

// cara menambahkan property baru di object
	- myobj.namaPropertyBaru = value;

// cara mengubah value property object
	- myobj.namaProperty = 'value baru';



## Array

// cara menambah nilai array di akhir index
	- myarray.push(value1, value2, ...);

// cara menghapus 1 nilai(beserta indexnya) di index akhir array
	- myarr.pop();

// cara menambah nilai di awal index array
	- myarr.unshift(value1, value2, ...);

// cara menghapus 1 nilai(beserta indexnya) di index awal array
	- myarr.shift(); 

// cara menghapus nilai array saja dan membiarkan indexnya tidak bernilai
	- delete myarr[index];
		-> output dari nilai array yg dihapus : <1 empty item>

// cara menghapus nilai(beserta indexnya) array pada index yang ditentukan, dan bisa juga menambah nilai dari index yang dihapus
	- myarr.splice(awal-index-yang-dihapus, jml-index-yang-ingin-dihapus, valueBaru1(opsional), valueBaru2, ....);


## Spread Operator
!! dengan menggunakan spread operator maka kita melakukan copy paste nilai array dan object dengan benar(tanpa reference)

// contoh : 
	// jika seperti ini
	console.log(...favorites);
	// maka ==
	console.log(favorites[0], favorites[1], favorites[2], favorites[3]);

	// Array
	const favorites = ["Seafood", "Salad", "Nugget", "Soup"];
	const others = ["Cake", "Pie", "Donut"];

	const allFavorites = [...favorites, ...others];

	console.log(allFavorites);

	/* output
	[ 'Seafood', 'Salad', 'Nugget', 'Soup', 'Cake', 'Pie', 'Donut' ]
	*/

	// Object
	const obj1 = { firstName: 'Obi-Wan', age: 30 };
	const obj2 = { lastName: 'Kenobi', gender: 'M' };

	const newObj = { ...obj1, ...obj2 };

	console.log(newObj);

	/* output
	{ firstName: 'Obi-Wan', age: 30, lastName: 'Kenobi', gender: 'M' }
	*/

## Destructuring Object
! Penulisan sintaksis destructuring object pada ES6 menggunakan object literal ({ }) di sisi kiri dari operator assignment.

// contoh : 
	const profile = {
	    firstName: "John",
	    lastName: "Doe",
	    age: 18
	}
	 
	const {firstName, lastName, age} = profile;
	 
	console.log(firstName, lastName, age);
	 
	/* output:
	John Doe 18
	*/
	------
	let firstName = "Dimas";
	let age = 20;
	 
	// menginisialisasi nilai baru melalui object destruction
	({firstName, age} = profile); // wajib memakai () 


### Default Values
// contoh : 
	const profile = {
	    firstName: "John",
	    lastName: "Doe",
	    age: 18
	}
	 
	- const {firstName, age, isMale = false} = profile;

### Assigning to Different Local Variable Names
// contoh : 
	const profile = {
	    firstName: "John",
	    lastName: "Doe",
	    age: 18
	}
	 
	const {firstName: localFirstName = 'febri', lastName: localLastName, age: localAge} = profile;
	 

## Destruturing Array
// contoh : 
	const favorites = ["Seafood", "Salad", "Nugget", "Soup"];
	const [firstFood, secondFood, thirdFood, fourthFood] = favorites;
 	----- 
	const favorites = ["Seafood", "Salad", "Nugget", "Soup"];
 	const [, , thirdFood ] = favorites;
 	// Destructuring Assignment
 	const favorites = ["Seafood", "Salad", "Nugget", "Soup"];
 
	let myFood = "Ice Cream";
	let herFood = "Noodles";
	 
	[myFood, herFood] = favorites;
	------
	let a = 1;
	let b= 2;

	[a, b] = [b, a]
	// Default Values 
	const favorites = ["Seafood"];
 
	const [myFood, herFood = "Salad"] = favorites

## Map
! Map adalah tipe data yang menyimpan koleksi data dengan format key-value layaknya Object. Yang membedakan adalah Map memperbolehkan key dengan tipe data apa pun, dibandingkan Object yang hanya mengizinkan key bertipe String atau Symbol.

! Untuk mendefinisikan Map gunakan constructor seperti di bawah ini: 
	- const myMap = new Map();

! Apabila ingin menetapkan nilai dari Map secara langsung, gunakan array multi dimensi seperti ini:
	const myMap = new Map([
	    ['1', 'a String key'],
	    [1, 'a number key'],
	    [true, true]
	]);

	console.log(myMap);

	/* output
	Map(3) { '1' => 'a String key', 1 => 'a number key', true => true }
	*/

! Ketika sudah membuat objek Map, kita bisa mendapatkan nilainya berdasarkan key tertentu dengan metode get(). Lalu, untuk menambahkan pasangan key-value baru gunakan metode set().
	// contoh : 
		const capital = new Map([
		    ["Jakarta", "Indonesia"],
		    ["London", "England"],
		    ["Tokyo", "Japan"]
		]);

		console.log(capital.size);
		console.log(capital.get("London"));
		capital.set("New Delhi", "India");
		console.log(capital.size);
		console.log(capital.get("New Delhi"));

		/* output
		3
		England
		4
		India
		 */

// metode untuk mengetahui apakah ada key dalam map
	// contoh : 
		const mymap = new Map([
		  ['name', 'febrianto'],
		  ['npm', 2018]
		]);

		console.log(mymap.has('name')); // output : true

// metode untuk menghapus key dan value map
	// contoh : 
		const mymap = new Map([
		  ['name', 'febrianto'],
		  ['npm', 2018]
		]);

		console.log(mymap.delete('name')); // output : true (berhasil menghapus)



## Set
! Struktur data yang akan kita bahas berikutnya adalah Set. Set sederhananya merupakan kumpulan nilai (set of values). Hal yang membedakan Set dengan struktur data yang lain adalah data pada Set tidak berurutan dan juga tidak diindeks. Selain itu, data di dalam Set juga bersifat unik dan tidak ada duplikasi. Perhatikan contoh deklarasi Set di bawah ini:
	const numberSet = new Set([1, 4, 6, 4, 1]);

	console.log(numberSet);

	/* output
	Set(3) { 1, 4, 6 }
	*/

// metode untuk menambahkan dan menghapus element set
	! Fungsi add() hanya menerima satu argumen. Jika Anda memasukkan array, maka array tersebut akan dianggap sebagai satu elemen sendiri. Nilai yang duplikat akan diabaikan.
	// contoh : 
		const numberSet = new Set([1, 4, 6, 4, 1]);
		numberSet.add(5);
		numberSet.add([98,43,23]);
		numberSet.add(6);

		numberSet.delete(4); // argumen yang dimasukkan ke dalam fungsi delete adalah nilai yang ingin dihapus, bukan index-nya.

		console.log(numberSet);

		/* output
		Set(4) { 1, 6, 5, [ 98, 43, 23 ] }
		*/


## WeakMap dan WeakSet
! WeakMap merupakan varian dari Map yang mendukung garbage collection. Garbage collection adalah proses di mana interpreter JavaScript mengambil kembali memori yang tidak lagi “dapat dijangkau” dan tidak dapat digunakan oleh program [3]. Garbage collection di JavaScript dilakukan secara otomatis dan bukan menjadi urusan dari developer.

! Yang dimaksud weak dalam WeakMap adalah referensi terhadap nilai yang disimpan. Apabila suatu nilai yang disimpan di WeakMap sudah tidak terjangkau atau tidak bisa lagi diakses, maka referensi ke memorinya akan dihapus.

! Berikut ini adalah beberapa hal yang membedakan antara Map dan WeakMap:
	- Key dari WeakMap harus berupa object atau array. Nilai primitif tidak bisa digunakan sebagai key karena tidak mendukung garbage collection.
	- WeakMap memiliki methodget(), set(), has(), dan delete(). Namun, WeakMap tidak termasuk kategori iterable sehingga tidak memiliki method keys(), values(), atau forEach().
	- WeakMap juga tidak memiliki property size. Ini karena ukuran WeakMap dapat berubah karena proses garbage collection.

// contoh : 
	// WeakMap()
	let visitsCountMap = new WeakMap(); // Menyimpan daftar user

	function countUser(user) {
	    let count = visitsCountMap.get(user) || 0;
	    visitsCountMap.set(user, count + 1);
	}

	let jonas = { name: "Jonas" };
	countUser(jonas);                // Menambahkan user "Jonas"

	jonas = null;                    // Data object "Jonas" dihapus

	console.log(visitsCountMap);

	/* output
	WeakMap { <items unknown> }
	*/


! Seperti halnya WeakMap, WeakSet adalah versi weak reference dari Set. Perbedaan antara WeakSet dan Set antara lain:
	- WeakSet tidak bisa menyimpan nilai primitif.
	- WeakSet bukan iterable dan hanya memiliki method add(), has(), dan delete().
	- WeakSet tidak memiliki properti size.



# Object-Oriented Programming (OOP) red
! Object Oriented Programming (OOP) adalah salah satu paradigma dalam dunia pemrograman komputer. Ia adalah pendekatan berbasis objek, di mana suatu objek terdiri dari kumpulan atribut dan method di dalamnya. Di dalam JavaScript, atribut adalah variabel yang digunakan untuk menyimpan nilai. Sementara method adalah fungsi yang digunakan untuk menjalankan suatu proses.

!! paradigma OOP terdapat 4 pilar utama, yaitu encapsulation, abstraction, inheritance, dan polymorphism.



## Class
! JavaScript memiliki konsep bernama prototype. Prototype adalah properti internal yang akan selalu ada ketika sebuah objek dibuat

// Penulisan method menggunakan prototype 
	function Mail() {
	    this.from = 'pengirim@dicoding.com';
	};
	 
	Mail.prototype.sendMessage = function n(msg, to) {
	  console.log(`you send: ${msg} to ${to} from ${this.from}`);
	};

	// pemanggilan
 
	const mail1 = new Mail();
	mail1.sendMessage('hallo', 'penerima@dicoding.com');

// Penulusan method tanpa pendekatan prototype
	function Mail(){
	    this.from = "pengirim@dicoding.com",
	  	this.sendMessage = function(msg, to) {
	    console.log(`you send: ${msg} to ${to} from ${this.from}`);
	  } 
	};	

	// pemanggilan
 
	const mail1 = new Mail();
	mail1.sendMessage('hallo', 'penerima@dicoding.com');

!! penggunaan sintaksis class pada javascript hanyalah syntatic sugar dari prototype itu sendiri.


## Property & Method
! di dalam JavaScript sendiri terdapat 2 jenis akses identifier untuk sebuah field:
	- Public : dapat diakses dari mana pun.
	- Private : hanya dapat diakses dari dalam kelas itu sendiri.

// contoh cara membuat property/method yang bersifat private 
	class Mail {
	    constructor() {
	        this._contacts = []; // dengan menambahkan '_' sebelum nama property/methodnya
	        this.from = 'pengirim@dicoding.com';
	    }
	    sendMessage(msg, to) {
		    console.log(`you send: ${msg} to ${to} from ${this.from}`);
		};
	}

	// private pada contructor function
	function Mail() {
	    this.from = 'pengirim@dicoding.com';
	    let contacts = []; // membuat property/method private
	}

## 4 Pilar OOP
! Enkapsulasi adalah kondisi di mana attribute atau method di dalam class dibungkus dan bersifat privat. Artinya objek lain tidak bisa mengakses atau mengubah nilai dari property secara langsung.

! Abstraksi dapat dikatakan merupakan penerapan alami dari enkapsulasi. Abstraksi berarti sebuah objek hanya menunjukkan operasinya secara high-level. Misalnya kita cukup tahu bagaimana bagaimana pesan dikirim atau diterima, namun kita tidak perlu tahu seperti apa proses enkripsi dan dekripsi isi pesan, atau bagaimana sebuah daftar contact dapat bertambah.

### Inheritance
! Beberapa objek bisa memiliki beberapa karakteristik atau perilaku yang sama, tetapi mereka bukanlah objek yang sama. Di sinilah inheritance atau pewarisan berperan

// contoh : 
	class Mail {
	    constructor(author) {
	        this.from = author;
	        this._contacts = [];
	    }
	    sendMessage(msg, to) {
	        console.log(`you send: ${msg} to ${to} from ${this.from}`);
	        this._contacts.push(to);
	    }
	    showAllContacts() {
	        return this._contacts;
	    }
	}

	class WhatsApp extends Mail {
	    constructor() {
	        super(); // !! wajib ada ini untuk inheritancenya
	        this.username = 'dicoding';
	        this.isBussinessAccount = true;
	    }
	    myProfile() {
	        return `my name ${this.username}, is ${this.isBussinessAccount ? 'Business' : 'Personal'}`;
	    }
	}

	const wa1 = new WhatsApp(080111000222);
	console.log(wa1.myProfile());
	// my name dicoding, is Business


### Polymorphism
! Polymorphism dalam bahasa Yunani berarti “banyak bentuk”. Sederhananya objek dapat memiliki bentuk atau implementasi yang berbeda-beda pada satu metode yang sama. Semua jenis Mail dapat mengirim pesan, namun whatsapp, email, sms tentunya memiliki cara yang berbeda dalam mengirim pesan, misalkan: whatsapp dapat mengirim pesan suara sedangkan yang lainnya tidak, email dapat menyaring konten spam saat mengirim pesan sedangkan yang lain tidak. Perbedaan bentuk atau cara mengirim pesan tersebut merupakan contoh dari polymorphism.



## Overriding Method
! Overriding adalah teknik untuk kita melakukan perombakan (baik secara keseluruhan maupun tidak) pada sebuah method ataupun constructor yang dimiliki oleh parent class. Sehingga, ia dapat disesuaikan dengan behavior di child class.


### Overriding Constructor
! pada kasus sebelumnya bagaimanan jika kita menambahkan username dan isBussinessAccount ke dalam constructor?
	class WhatsApp extends Mail {
	    constructor(username, isBussinessAccount, phone) {
	        super();
	        this.username = username;
	        this.isBussinessAccount = isBussinessAccount;
	    }
	}
	 
	const wa1 = new WhatsApp('dicoding', true, 089989090898);
	/**
	Error:
	Must call super constructor in derived class before accessing 'this' or returning from derived constructor
	**/

	! Eror di atas terjadi karena constructor pada kelas parent gagal dieksekusi, meskipun kita telah menggunakan operator this.nameOfProperty. Solusinya kita dapat menggunakan operator super() untuk mengeksekusi method parent-nya. Sehingga, constructor pada kelas WhatsApp menjadi seperti ini.
		constructor(username, isBussinessAccount, phone) {
		  super(phone);
		  this.username = username;
		  this.isBussinessAccount = true;
		}


## Overriding Method
! Pada dasarnya semua method yang ada pada kelas parent dapat diakses langsung di child kelasnya (as is).

// contoh override pada method sendMessage.
	class WhatsApp extends Mail {
	    constructor(username, isBussinessAccount, phone) {
	        super(phone);
	        this.username = username;
	        this.isBussinessAccount = isBussinessAccount;
	    }
	 
	    // Overriding method => Melakukan Override Total
	    sendMessage(msg, to) {
	        console.log('Send by WA');
	    }
	}
	! Ketika kita memanggil method sendMessage pada contoh di atas, ia hanya akan mengeksekusi kode yang ada pada child class.

	! Untuk tetap melakukan eksekusi kode pada parent class maka perlu menggunakan operator super.methodName().
		sendMessage(msg, to) {
		    super.sendMessage(msg, to);
		    console.log('Send by WA');
		}


## Object Composition
! Object composition adalah prinsip komposisi dari sebuah alur bisnis tanpa perlu melakukan pewarisan dari parent class. Prinsip ini didasarkan pada kumpulan perilaku (method/function) yang sudah kita definisikan. Sehingga, ketika ingin membuat alur bisnis lain dengan beberapa perilaku (method) yang sama, kita dapat menggunakan fungsi yang sudah ada tanpa melakukan inheritance/pewarisan.

// contoh : 
	// [1] list of abstractions
	const canSendMessage = self => ({
	    sendMessage: () => console.log('send message:', self.message)
	  });

	const checkIsValidPhone = self => ({
	    isValid: () => console.log('valid phone', self.from)
	  });

	// [2] crate object composition
	const personalEnterprise = (from, message, store) => {
	  // [3] attributes
	  const self = {
	    from,
	    message,
	    store
	  };
	  // [4] method
	  const personalEnterpriseBehaviors = self => ({
	    createCatalog: () => console.log('Catalog has created: ', self.store)
	  });
	  
	  // [5] create object composition
	  return Object.assign(self, personalEnterpriseBehaviors(self), canSendMessage(self), checkIsValidPhone(self));
	};

	const pe1 = personalEnterprise('pengirim@gmail.com', 'hei produk baru nih', 'Dicoding Store');
	pe1.createCatalog(); //Catalog has created:  Dicoding Store
	pe1.sendMessage(); //send message: hei produk baru nih

! Penjabaran kode di atas:
	1. Kita membuat sebuah abstraksi untuk method-method yang umum digunakan (di sini misalkan method mengirim pesan, dan validasi nomor hp).
	2. Kita membuat sebuah kelas baru dengan nama personalEnterprise, di mana seperti biasa kita dapat menggunakan parameter yang akan digunakan.
	3. Pada  object composition ini, penggunaan parameter biasa digunakan untuk mendaftarkan attribute-attribute dari kelas tersebut. Pada contoh di atas, kita mengumpulkan attribute tersebut pada konstanta bernama self atau state.
	4. Method, kita dapat juga menambahkan method/fungsi yang spesifik hanya ada pada kelas tersebut (kapabilitasnya hanya pada kelas tersebut / tidak umum).
	5. Proses pembuatan object dengan perintah Object.assign(attribute, method1, method2, methodN).


## Built-in Class
! Dalam JavaScript sendiri terdapat built-in class bawaan, misalnya Date, Object, Array, Math, dan String. Built-in class tersebut dapat digunakan untuk memanipulasi data-data terkait dengan array, perintah matematik, manipulasi karakter, dan manipulasi objek.

// contoh built-in class Date
	! dalam meng-instansiasi Date object tersebut dengan 4 cara:
	// #1 tanpa parameter, yang berarti `myDate` akan berisi tanggal dan waktu saat ini
	const myDate = new Date(); 
	 
	// #2 parameter tanggal dalam bentuk string, misal  "January 01, 2021" 
	const myDate = new Date(dateString); 
	 
	// #3 parameter dalam bentuk number, misal 87400000
	const myDate = new Date(miliseconds); 
	 
	// #4 parameter tanggal dalam bentuk number (7 parameter), [hour,minute,second,millisecond] bersifat opsional
	const myDate = new Date(year,month,date,hour,minute,second,millisecond); 

! Dalam object Date terdapat beberapa method yang dapat kita gunakan. Berikut adalah daftar method yang umum digunakan. (format: method - definisi <br> contoh)
	- getMonth() - Nilai kembaliannya adalah bulan dalam bentuk angka (0 sampai 11), 0 berarti Januari.	
		myDate.getMonth()
	- getFullYear() - Nilai kembaliannya adalah tahun, misalkan 2021.	
		myDate.getFullYear()
	- getDate() - Nilai kembaliannya adalah tanggal dari 1 sampai 31.
		myDate.getDate()
	- getHours() - Nilai kembaliannya adalah jam dari 0 sampai 23	
		myDate.getHours()
	- getMinutes() - Nilai kembaliannya adalah menit dari 0 sampai 59 Nilai kembaliannya	myDate.getMinutes()
	- getSeconds() - Nilai kembaliannya adalah detik dari 0 sampai 59	
		myDate.getSeconds()
	- getMilliseconds() - Nilai kembaliannya adalah mili-detik dari 0 to 999	
		myDate.getMilliseconds()
	- getTime() - Nilai kembaliannya adalah waktu dalam bentuk epoch mili-detik (dimulai dari 1 January, 1970 yang berarti 0)	
		myDate.getTime()
	- getDay() - Nilai kembaliannya adalah hari dalam seminggu dari 0 sampai 6. 0 berarti minggu	
		myDate.getDay()

! Selain itu, juga terdapat static method yang dapat digunakan tanpa perlu melakukan instansiasi, yaitu:
	- parse(datestring)	digunakan untuk merubah tanggal dalam format string, menjadi epoch miliseconds	
		Date.parse("2021-01-01")


### Date String Format
! Format date string sendiri, secara umum terdiri dari:
	- YYYY 4 digit tahun, misalkan : 2021
	- MM -> 2 digit bulan, misalkan : 01 berarti Januari
	- DD -> 2 digit tanggal 0 sampai 31
	- HH -> 2 digit jam 0 sampai 23
	- mm -> 2 digit menit 0 sampai 59
	- ss -> 2 detik detik 0 sampai 49
	- sss -> 3 digit milidetik 0 sampai 999
	- - -> Pemisah untuk tanggal
	- : -> Pemisah untuk waktu
	- Z -> Berarti tanggal akan diatur sebagai UTC

// contoh built-in class lainnya
	const listOfContent = [1,2,”President”, {}];
	console.log(Array.isArray(listOfContent)); 
	// result is true
	 
	const splitText = "12:20:00".split(':');
	// result is [ '12', '20', '00' ]


## Rangkuman 
! Berikut ini beberapa materi tambahan yang bisa Anda pelajari untuk mendalami seputar Object-Oriented Programming (OOP):
	- oop for beginner : https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS
	- a guide oop in js : https://betterprogramming.pub/object-oriented-programming-in-javascript-b3bda28d3e81




# Functional Programming red
! Paradigma Functional Programming adalah paradigma pemrograman di mana proses komputasi didasarkan pada fungsi matematika murni. Functional Programming (selanjutnya akan kita singkat menjadi FP) ditulis dengan gaya deklaratif yang berfokus pada “what to solve” dibanding “how to solve” yang dianut oleh gaya imperatif.

## Konsep - Konsep FP
! 4 konsep besar yang ada di FP(Functional Programming). Yakni Pure Function, Immutability, Recursive, dan High-Order Function.

### Pure Function 
! Salah satu konsep besar dari paradigma FP adalah Pure Function. Apa artinya? Pure Function merupakan konsep dari pembuatan fungsi yang mengharuskan fungsi untuk tidak bergantung terhadap nilai yang berada di luar fungsi atau parameternya. Sehingga mau seperti apa keadaanya, fungsi yang dibuat selalu menghasilkan sesuatu yang sama, terkecuali bila fungsi tersebut diberikan nilai parameter yang berbeda.
! pure function juga dilarang keras untuk mengubah nilai yang berada di luar baik secara sengaja atau tidak sengaja.

! Agar lebih mudah dalam mengetahui apakah fungsi yang Anda buat sudah pure atau belum, pastikan 3 konsep ini ada pada fungsi yang Anda buat.
	- Mengembalikan nilai yang sama bila inputannya (nilai parameter) sama.
	- Hanya bergantung pada argumen yang diberikan.
	- Tidak menimbulkan efek samping.

### Immutability 
! Konsep yang kedua adalah immutability. Immutable berarti sebuah objek tidak boleh diubah setelah objek tersebut dibuat. Kontras dengan mutable yang artinya objek boleh diubah setelah objek tersebut dibuat.
! contoh penggunaan array map. Ketika menggunakan array.map(), alih-alih ia mengubah nilai dari array itu sendiri, malah ia membuat atau menghasilkan array baru.

// cotoh
	const user = {
	    firstname: 'Harry',
	    lastName: 'Protter', // ups, typo!
	}

	const createUserWithNewLastName = (newLastName, user) => {
	    return { ...user, lastName: newLastName }
	}

	const newUser = createUserWithNewLastName('Potter', user);

	console.log(newUser);

### Higher-Order Function
! JavaScript memiliki kemampuan First Class Functions, karena itu fungsi pada JavaScript dapat diperlakukan layaknya sebuah data. Kita bisa menyimpan function dalam variabel, memberikan function sebagai parameter pada fungsi lainnya, hingga mengembalikan function di dalam function.

! Higher-Order Function merupakan fungsi yang dapat menerima fungsi lainnya pada argumen; mengembalikan sebuah fungsi; atau bahkan keduanya.

! Teknik Higher-Order Function biasanya digunakan untuk:
	- Mengabstraksi atau mengisolasi sebuah aksi, event, atau menangani alur asynchronous menggunakan callback, promise, dan lainnya.
	- Membuat utilities yang dapat digunakan diberbagai tipe data.
	- Membuat teknik currying atau function composition.

// contoh currying ???
	function curry(f) { // curry(f) does the currying transform
	  return function(a) {
	    return function(b) {
	      return f(a, b);
	    };
	  };
	}

	// usage
	function sum(a, b) {
	  return a + b;
	}

	let curriedSum = curry(sum);

	alert( curriedSum(1)(2) ); // 3



## Reusable Function 
! kita akan coba membahas dan menggunakan beberapa reusable function yang sudah ada di JavaScript. Khususnya beberapa Higher-Order Function yang dimiliki array, seperti map, filter, dan forEach.

### Array Filter
// contoh : 
	const truthyArray = [1, '', 'Hallo', 0, null, 'Harry', 14].filter((item) => Boolean(item));

	console.log(truthyArray);

	/*
	 * output:
	 * [ 1, 'Hallo', 'Harry', 14 ]
	 * 
 	*/

### Array Find
! Yang membedakan array.find() dengan array.some(), find akan menghasilkan satu nilai dari elemen yang pertama kali ditemukan berdasarkan kriteria tertentu dan akan menghasilkan nilai undefine bila tidak ada kriteria yang terpenuhi pada item array.

// contoh : 
	const students = [
	  {
	    name: 'Harry',
	    score: 60,
	  },
	  {
	    name: 'James',
	    score: 88,
	  },
	  {
	    name: 'Ron',
	    score: 90,
	  },
	  {
	    name: 'Bethy',
	    score: 75,
	  }
	];

	const findJames = students.find(student => student.name === 'James');
	console.log(findJames);

	/**
	output
	{ name: 'James', score: 88 }
	**/


### Array sort
! array.sort() merupakan fungsi bawaan dari array yang berguna untuk melakukan pengurutan nilai dari sebuah deretan nilai. Secara default, fungsi sort akan mengubah semua nilai dalam deretan menjadi bentuk string dan mengurutkannya secara ascending.

// contoh : 
	const months = ['March', 'Jan', 'Feb', 'Dec'];
	months.sort();
	console.log(months);
	// output: [ 'Dec', 'Feb', 'Jan', 'March' ]

	const array1 = [1, 30, 4, 1000, 101, 121];
	array1.sort();
	console.log(array1);
	// output: [ 1, 1000, 101, 121, 30, 4 ] // tidak terurut


// contoh sort tipe data number
	const array1 = [1, 30, 4, 1000];

	const compareNumber = (a, b) => {
	  return a - b;
	};
	const sorting = array1.sort(compareNumber);
	console.log(sorting);

	/**
	output
	[ 1, 4, 30, 1000 ]
	**/

	! Pada compare function, fungsi akan membandingkan 2 nilai yang akan menghasilkan 3 result yaitu negatif (-), 0, dan positif (+).
		- Jika, negative maka `a` akan diletakan sebelum `b`
		- Jika, positive maka `b` akan diletakan sebelum `a`
		- Jika, 0 maka tidak ada perubahan posisi.


### Array every
! array.every() merupakan fungsi bawaan dari array yang digunakan untuk mengecheck apakah semua nilai dari sebuah array sesuai dengan kriteria yang didefinisikan. Kembalian dari array.every() adalah nilai Boolean.

// contoh : 
	const scores = [70,85,90];
	const minimumScore = 65;

	const examPassed = scores.every(score => score >= minimumScore);
	console.log(examPassed);

	/**
	output
	true
	**/



# Setup Environment red

## Node.js
! Node.js adalah runtime environment untuk JavaScript yang bersifat open-source dan cross-platform. Dengan Node.js kita dapat menjalankan kode JavaScript di mana pun, tidak hanya terbatas pada lingkungan browser.

! Berikut ini adalah beberapa fitur penting dari Node.js yang menjadikannya pilihan utama dalam pengembangan aplikasi:
	- Asynchronous & Event-driven
		Semua API dari Node.js bersifat asynchronous, artinya tidak memblokir proses lain sembari menunggu satu proses selesai. Server Node.js akan melanjutkan ke ke pemanggilan API berikutnya lalu memanfaatkan mekanisme event notification untuk mendapatkan respon dari panggilan API sebelumnya.
	- Very Fast
		Eksekusi kode dengan Node.js sangat cepat karena berjalan pada V8 JavaScript Engine dari Google Chrome.
	- Single Threaded but Highly Scalable
		Node.js menggunakan model single thread dengan event looping. Mekanisme ini membantu server untuk merespon secara asynchronous dan menjadikan server lebih scalable dibandingkan server tradisional yang menggunakan banyak thread untuk menangani permintaan.


# Module

## Export dan Import
// contoh : 
	// di file state.js
	...
	module.exports = coffeeStock;

	// di file index.js
	const coffeeStock = require('./state');
	....

## Export Beberapa Nilai pada Node.js
// contoh : 
	// di file state.js
	...
	module.exports = {coffeeStock, isCoffeeMachineReady}; 

	// di file index.js
	const {coffeeStock, isCoffeeMachineReady} = require('./state');
	....


## ES6 Module
! Pada ES6 module, jika kita hanya mengekspor satu nilai pada sebuah berkas JavaScript baik itu primitive value, function, array, object, atau class, kita gunakan keyword export default.
// contoh : 
	const coffeeStock = {
	    arabica: 100,
	    robusta: 150,
	    liberica: 200
	};
	 
	export default coffeeStock;	
	// -> Lalu untuk mengimpor nilainya kita dapat menggunakan keyword import … from seperti berikut ini:

	import coffeeStock from "./state.js"; // wajib pke .js

	! Berbeda dengan gaya Node.js, kita gunakan keyword import ketika mendeklarasikan variabel yang di-import. Kita juga menggunakan keyword from untuk menentukan lokasi berkas JavaScript-nya.
	! Ketika menggunakan export default, kita dapat menggunakan penamaan apa saja saat mendeklarasikan variabel untuk menyimpan nilai yang diimpor.
		! Hal tersebut aman untuk dilakukan karena dengan menggunakan export default dapat dipastikan hanya satu nilai yang diekspor pada satu berkas JavaScript.
	!! Saat ini, fitur ES6 module tidak secara default diaktifkan. kita dapat mengaktifkannya dengan cara Tambahkan properti 'type' dengan nilai 'module' pada berkas package.json
		// contoh : 
			{
			  "name": "coffeemachine",
			  "version": "1.0.0",
			  "description": "",
			  "main": "index.js",
			  "type": "module",
			  "scripts": {
			    "test": "echo \"Error: no test specified\" && exit 1",
			    "start": "node index.js"
			  },
			  "author": "",
			  "license": "ISC"
			}

// mengekspor banyak nilai dalam satu berkas JavaScript menggunakan ES6.
	! Named export digunakan untuk mengekspor banyak nilai dalam berkas JavaScript. Cara kerjanya mirip seperti pada Node.js. Nilai yang akan diekspor dituliskan di dalam object literals, seperti ini:
		const coffeeStock = {
		    arabica: 100,
		    robusta: 150,
		    liberica: 200
		};
		 
		const isCoffeeMachineReady = true;
		 
		export {coffeeStock, isCoffeeMachineReady};

	// -> Lalu untuk mendapatkan nilai yang diekspor melalui named export, kita gunakan destructuring object.
		import { coffeeStock as namaAlias(opsional), isCoffeeMachineReady } from './state.js';
		 
		console.log(namaAlias);
		console.log(isCoffeeMachineReady);
		 
		/* output
		{ arabica: 100, robusta: 150, liberica: 200 }
		true
		*/


# Penanganan Error red

## Try and Catch
// contoh : 
	try {
	    console.log("Awal blok try");   // (1)
	    errorCode;                      // (2)
	    console.log("Akhir blok try");  // (3)
	} catch (error) {
	    console.log(error.name);
	    console.log(error.message);
	    console.log(error.stack);
	}
	 
	/* output
	Awal blok try
	ReferenceError
	errorCode is not defined
	ReferenceError: errorCode is not defined
	    at file:///home/dicoding/Playground/javascript/CoffeeMachine/error.js:3:5
	    at ModuleJob.run (internal/modules/esm/module_job.js:152:23)
	    at async Loader.import (internal/modules/esm/loader.js:166:24)
	    at async Object.loadESM (internal/process/esm_loader.js:68:5)
	*/


! Object error memiliki beberapa properti utama di dalamnya, yaitu:
	- name : Nama error yang terjadi.
	- message : Pesan tentang detail error.
	- stack : Informasi urutan kejadian yang menyebabkan error. Umumnya digunakan untuk debugging karena terdapat informasi baris mana yang menyebabkan error.


### try-catch-finally
! Blok finally akan tetap dijalankan tanpa peduli apa pun hasil yang terjadi pada blok try-catch.
// contoh : 
	try {
	    console.log("Awal blok try");
	    console.log("Akhir blok try");
	} catch (error) {
	    console.log("Baris ini diabaikan");
	} finally {
	    console.log("Akan tetap dieksekusi");
	}


## Throwing Error
! Operator throw ini akan “melemparkan” eror pada program, sehingga eksekusi kode akan masuk pada blok catch
// contoh : 
	let json = '{ "name": "Yoda", "age": 20 }';
	 
	try {
	    let user = JSON.parse(json);
	 
	    if (!user.name) {
	        throw new SyntaxError("'name' is required.");
	    }
	 
	    errorCode;
	 
	    console.log(user.name); // Yoda
	    console.log(user.age);  // 20
	} catch (error) {
		
	    if (error instanceof SyntaxError) {
	        console.log(`JSON Error: ${error.message}`);
	    } else if (error instanceof ReferenceError) {
	        console.log(error.message);
	    } else {
	        console.log(error.stack);
	    }
	}
	 
	/* output
	errorCode is not defined
	*/

	! Dengan operator instanceOf, kita bisa mendapatkan tipe dari eror yang terjadi. Dari sana kita bisa membuat percabangan bagaimana cara menangani erornya.


## Custom Error
! Untuk itu kita bisa membuat kelas Error kita sendiri dengan nama dan pesan yang lebih sesuai. Kelas ini merupakan turunan dari kelas Error yang sudah ada : 
	class ValidationError extends Error {
	    constructor(message) {
	        super(message);
	        this.name = "ValidationError";
	    }
	}

// contoh custom error
	class ValidationError extends Error {
	    constructor(message) {
	        super(message);
	        // this.name = "ValidationError"; // ini buat apaan?
	    }
	}
	 
	let json = '{ "age": 30 }';
	 
	try {
	    let user = JSON.parse(json);
	 
	    if (!user.name) {
	        throw new ValidationError("'name' is required.");
	    }
	    if (!user.age) {
	        throw new ValidationError("'age' is required.");
	    }
	 
	    console.log(user.name);
	    console.log(user.age);
	} catch (error) {
	    if (error instanceof SyntaxError) {
	        console.log(`JSON Syntax Error: ${error.message}`);
	    } else if (error instanceof ValidationError) {
	        console.log(`Invalid data: ${error.message}`);
	    } else if (error instanceof ReferenceError) {
	        console.log(error.message);
	    } else {
	        console.log(error.stack);
	    }
	}
	 
	/* output
	Invalid data: 'name' is required.
	*/




# Concurrency red
! Concurrency sendiri berarti beberapa komputasi yang terjadi pada saat yang bersamaan
## Asynchronous vs Synchronous

## setTimeout

## Callback Function 
// contoh : 
	const orderCoffee = callback => {
	    let coffee = null;
	    console.log("Sedang membuat kopi, silakan tunggu...");
	    setTimeout(() => {
	        coffee = "Kopi sudah jadi!";
	        callback(coffee);
	    }, 3000);
	}
	 
	 
	orderCoffee(coffee => {
	    console.log(coffee);
	});
	 
	 
	/* output
	Sedang membuat kopi, silakan tunggu...
	---- setelah 3 detik ----
	Kopi sudah jadi!
	*/


## Promise
! Dengan Promise, kita dapat meminimalisir callback hell dan mengubahnya menjadi kode yang sangat mudah dibaca. 
! Promise merupakan salah satu fitur penting dari ES6. Promise ini dapat menggantikan peran callback dengan menggunakan ciri khas fungsi .then-nya.
! Promise memiliki tiga kondisi, yaitu:
	- Pending (Janji sedang dalam proses)
	- Fulfilled (Janji terpenuhi)
	- Rejected (Janji gagal terpenuhi)




## Contructing Promise
! Promise merupakan sebuah objek yang digunakan untuk membuat sebuah komputasi (kode) ditangguhkan dan berjalan secara asynchronous [5]. Untuk membuat objek promise, kita gunakan keyword new diikuti dengan constructor dari Promise

// contoh
	const executorFunction = (resolve, reject) => {
	    const isCoffeeMakerReady = true;
	    if (isCoffeeMakerReady) {
	        resolve("Kopi berhasil dibuat");
	    } else {
	        reject("Mesin kopi tidak bisa digunakan");
	    }
	}
	 
	 
	const makeCoffee = () => {
	    return new Promise(executorFunction);
	}
	const coffeePromise = makeCoffee();
	console.log(coffeePromise);
	 
	 
	/* output
	Promise { 'Kopi berhasil dibuat' } // ! masih dalam bentuk promise
	*/
	! Executor function memiliki dua parameter, yaitu resolve dan reject yang berupa fungsi. Berikut penjelasan detailnya:
		- resolve() adalah parameter pertama pada executor function. Parameter ini merupakan fungsi yang dapat menerima satu parameter. Biasanya kita gunakan untuk mengirimkan data ketika promise berhasil dilakukan. Ketika fungsi ini terpanggil, kondisi Promise akan berubah dari pending menjadi fulfilled.
		- reject() adalah parameter kedua pada executor function. Parameter ini merupakan fungsi yang dapat menerima satu parameter dan digunakan untuk memberikan alasan kenapa Promise tidak dapat terpenuhi. Ketika fungsi ini terpanggil, kondisi Promise akan berubah dari pending menjadi rejected.


## Consuming Promises
! Untuk menangani hasil dari Promise, kita gunakan method .then(). Jika kita terjemahkan, “then” berarti “kemudian”, sehingga kurang lebih kita memerintahkan JavaScript seperti ini: “Jika janji saya sudah selesai, kemudian lakukan ...”.
// contoh :
	const stock = {
	    coffeeBeans: 250,
	    water: 1000,
	}
	 
	const checkStock = () => {
	    return new Promise((resolve, reject) => {
	        if (stock.coffeeBeans >= 16 && stock.water >= 250) {
	            resolve("Stok cukup. Bisa membuat kopi");
	        } else {
	            reject("Stok tidak cukup");
	        }
	    });
	});
	 
	const handleSuccess = resolvedValue => {
	    console.log(resolvedValue);
	}
	 
	const handleFailure = rejectionReason => {
	    console.log(rejectionReason);
	}
	 
	checkStock().then(handleSuccess, handleFailure);

	! Mari kita bedah kode di atas:
		- checkStock() merupakan fungsi yang mengembalikan promise dan akan menghasilkan resolve() dengan membawa nilai “Stok cukup. Bisa membuat kopi”.
		- Lalu kita mendeklarasikan fungsi handleSuccess() dan handleFailure() yang mencetak nilai dari parameternya.
		- Kemudian kita memanggil method .then() dari checkStock. Isi parameter then() dengan dua fungsi handler yang telah kita buat sebelumnya.
		- Parameter pertama berisi fungsi handleSuccess untuk menangani kondisi ketika promise berstatus resolve. Parameter kedua berisi fungsi handleFailure yang menangani ketika promise berstatus reject.


## onRejected with Catch Method
! Salah satu cara menulis kode yang baik adalah mengikuti prinsip yang disebut separation of concerns atau pemisahan masalah. Pemisahan masalah berarti mengorganisasikan kode ke dalam bagian-bagian yang berbeda berdasarkan tugas tertentu. Hal ini akan memudahkan kita kelak mencari kode yang salah jika aplikasi tidak bekerja dengan baik.
! Perlu diketahui bahwa method .then() akan mengembalikan nilai promise yang sama dengan ketika objek promise itu dipanggil. Melalui sifatnya ini, daripada kita menetapkan logika resolve dan reject pada satu method then(), kita dapat memisahkan kedua logika tersebut menggunakan masing-masing method then() seperti ini:
	checkStock()
	  .then(handleSuccess)
	  .then(null, handleFailure);

	-> Namun untuk menetapkan onRejected handler, kita perlu memberikan nilai null pada parameter pertama method .then(). Hal ini sedikit merepotkan bukan? Solusinya kita dapat menggunakan method lain, yakni .catch().
		checkStock()
		  .then(handleSuccess)
		  .catch(handleFailure);


## Chaining Promises
	// contoh : 
	const state = {
	    stock: {
	        coffeeBeans: 250,
	        water: 1000,
	    },
	    isCoffeeMachineBusy: false,
	}
	 
	const checkAvailability = () => {
	    return new Promise((resolve, reject) => {
	        setTimeout(() => {
	            if (!state.isCoffeeMachineBusy) {
	                resolve("Mesin kopi siap digunakan.");
	            } else {
	                reject("Maaf, mesin sedang sibuk.");
	            }
	        }, 1000);
	    });
	};
	 
	const checkStock = () => {
	    return new Promise((resolve, reject) => {
	        state.isCoffeeMachineBusy = true;
	        setTimeout(() => {
	            if (state.stock.coffeeBeans >= 16 && state.stock.water >= 250) {
	                resolve("Stok cukup. Bisa membuat kopi.");
	            } else {
	                reject("Stok tidak cukup!");
	            }
	        }, 1500);
	    });
	};
	 
	const brewCoffee = () => {
	    console.log("Membuatkan kopi Anda...")
	    return new Promise((resolve, reject) => {
	        setTimeout(() => {
	            resolve("Kopi sudah siap!")
	        }, 2000);
	    });
	};

	const boilWater = () => {
	    return new Promise((resolve, reject) => {
	        console.log("Memanaskan air...");
	        setTimeout(() => {
	            resolve("Air panas sudah siap!");
	        }, 2000);
	    })
	}
	 
	const grindCoffeeBeans = () => {
	    return new Promise((resolve, reject) => {
	        console.log("Menggiling biji kopi...");
	        setTimeout(() => {
	            resolve("Kopi sudah siap!");
	        }, 1000);
	    })
	}
	 
	function makeEspresso() {
	    checkAvailability()
	        .then((value) => {
	            console.log(value);
	            return checkStock();
	        })
	        .then((value) => {
	            console.log(value)
	            return brewCoffee();
	        })
	        .then(value => {
	            console.log(value);
	            state.isCoffeeMachineBusy = false;
	        })
	        .catch(rejectedReason => {
	            console.log(rejectedReason);
	            state.isCoffeeMachineBusy = false;
	        });
	}
	 
	makeEspresso();
	 
	/* output
	Mesin kopi siap digunakan.
	Stok cukup. Bisa membuat kopi.
	Membuatkan kopi Anda...
	Kopi sudah siap!
	*/	



## Promise All
! Method Promise.all() dapat menerima banyak promise dalam bentuk array pada parameternya. Kemudian method tersebut akan mengembalikan nilai seluruh hasil dari promise dalam bentuk array.
// contoh : 
	const promises = [firstPromise(), secondPromise(), thirdPromise()];
 
	Promise.all(promises)
	    .then(resolvedValue => {
	        console.log(resolvedValue);
	    });
	 
	/* output
	[ 'first promise', 'second promise', 'third promise' ]
	*/

! semua promise di dalam Promise.all() berjalan bersamaan dan menunggu sampai semua proses di dalamnya selesai dijalankan.
! Yang perlu kita perhatikan, urutan nilai yang dihasilkan oleh method ini sesuai dengan promise yang kita tentukan pada parameternya.


## Async-await
! Fitur async/await sebenarnya hanya syntactic sugar. Itu berarti secara fungsionalitas bukanlah sebuah fitur baru dalam JavaScript. Namun, hanya gaya penulisan baru yang dikembangkan dari kombinasi penggunaan Promise dan generator 
// contoh (Handle onRejected using async-await, chaining promise using async-await): 
	async function makeEspresso() {
	    try {
	        await checkAvailability();
	        await checkStock();
	        await Promise.all([boilWater(), grindCoffeeBeans()]);
	        const coffee = await brewCoffee();
	        console.log(coffee);
	    } catch (rejectedReason) {
	        console.log(rejectedReason);
	    }
	}



# Node Package Manager red
! Package manager merupakan tools yang dapat membantu pengelolaan package pada proyek agar lebih mudah
! NPM adalah salah satu package manager yang banyak digunakan oleh JavaScript developer dalam mengelola package, selain NPM ada juga Yarn Package Manager.
! NPM ini merupakan standard package manager yang disediakan oleh Node.js dan otomatis terpasang ketika memasang Node.js pada komputer kita.
! link npm : https://www.npmjs.com/


## Installing Packages
! Umumnya, semua package harus diinstal secara lokal. Ini memastikan setiap project atau aplikasi di komputer kita memiliki package dan versi yang sesuai dengan kebutuhan.
	- npm install <package-name>

! Sebuah package harus diinstal secara global hanya saat ia menyediakan perintah yang dapat dieksekusi dari CLI dan digunakan kembali di semua project. Beberapa contoh package yang perlu diinstal secara global, antara lain:
	- npm 
	- nodemon
	- mocha
	- create-react-app

! Untuk menginstal package secara global, kita cukup menambahkan parameter -g pada perintah npm install.
	- npm install -g <package-name>

! Objek dependencies pada file package.json merupakan objek yang menampung package yang kita gunakan untuk membuat aplikasi. Sedangkan objek devDependencies digunakan untuk package yang berkaitan hanya saat proses pengembangan aplikasi, contohnya seperti package jest yang digunakan untuk testing.

! Untuk memasang package sebagai devDependencies, kita bisa menambahkan parameter --save-dev pada perintah npm install.
	- npm install <package-name> --save-dev

! jika kita melihat versi ~1.0.2 itu berarti npm dapat menginstal versi 1.0.2 atau versi patch terbaru seperti 1.0.4. Jika versi package dituliskan dengan caret seperti ^1.0.2, itu berarti npm dapat menginstall versi 1.0.2 atau versi minor terbaru seperti 1.1.0


$$-- Package Lodash
! Lodash adalah package yang berisi banyak utilitas untuk memudahkan kita dalam menulis kode JavaScript, khususnya yang berhubungan dengan array, object, string, dll.
! link : https://www.npmjs.com/package/lodash
// install lodash
	- npm install lodash

// contoh pemakaian 
	const _ = require('lodash');
 
	const myArray = [1, 2, 3, 4];
	const sum = _.sum(myArray);
	 
	console.log(sum);
	 
	/* output
	10
	*/

--$$


## Uninstall Package 
// sintaks
	- npm uninstall <package-name>
	- npm uninstall <package-name> --save-dev // untuk package yang terdapat pada devDependencies
	


# Javascript Testing red
! Sebuah proses pengujian perangkat lunak dapat dilakukan secara:
	- Manual
		Proses pengujian secara manual oleh seorang yang ditunjuk sebagai test, atau sebagian pengguna yang memang mendapatkan akses untuk pengujian pre-release. Proses ini biasanya berkaitan dengan usability, accessibility dari sebuah aplikasi.
	- Otomatis
		Proses pengujian secara otomatis dilakukan oleh komputer dengan menuliskan script khusus, biasanya dilakukan oleh software engineer langsung ataupun oleh seorang QA Engineer. Proses ini biasanya berkaitan dengan fungsionalitas dari sebuah aplikasi.

! Dari proses pengujian di atas, jenis-jenis pengujian dalam pengembangan perangkat lunak secara umum dapat dibagi menjadi 4 jenis pengujian, yaitu:
	- Static test
		Memastikan tidak adanya typo (naming convention yang standar) dan memastikan tidak ada error types.
	- Unit test
		Dilakukan untuk memastikan bahwa setiap unit kode yang kita tulis sudah bisa bekerja sesuai harapan. Unit sendiri berarti komponen terkecil yang dapat diuji secara terisolasi dalam perangkat lunak yang kita buat, dapat berupa fungsi bahkan kelas jika kita menggunakan paradigma OOP. Proses ini juga dapat diautomasikan.
	- Integration test
		Memastikan beberapa serangkaian fungsi yang saling ketergantungan satu sama lain berjalan semestinya. Proses pengujian ini dapat dilakukan secara diautomasikan dengan menuliskan script test.
	- End-to-End test
		Proses pengujian sebuah aplikasi untuk menguji flow dari awal hingga akhir, layaknya seorang user saat menggunakan aplikasi. Memastikan bahwasanya aplikasi berfungsi selayaknya. Biasanya proses ini dapat dilakukan secara otomatis maupun manual oleh tester.

! Ketika kita menulis sebuah kasus pengujian (test case), maka ada beberapa poin yang harus kita definisikan terlebih dahulu:

	- Apa yang ingin diuji?
		Misalkan: Melakukan uji pada fungsi menghitung rata-rata nilai siswa, atau dapat juga melakukan pengujian pada proses registrasi akun, dan lain sebagainya.
	- Ekspektasi apa yang diharapkan?
		- Untuk kasus menghitung nilai rata-rata:
		- Menghasilkan output perhitungan yang sesuai berdasarkan input yang diberikan.
		- Input harus berupa angka.
	- Untuk kasus proses registrasi akun:
		- Pengguna dapat melakukan registrasi secara normal.
		- Pengguna dengan email sama tidak dapat melakukan registrasi.
		- dan lain sebagainya.


## $$-- Jest 
// cara install
	! link : https://jestjs.io/docs/using-matchers
	- npm install --save-dev jest

// contoh penggunaan untuk testing
	describe(‘pengujian olah aritmatika’, () => {
	   test(‘#1 dua tambah dua adalah empat’, () => {
	        expect(2+2).toBe(4);
	   });
	 
	   test(‘#2 dua kali tiga adalah enam, () => {
	        expect(2*3).toBe(6);
	   });
	});

! Dari contoh kode di atas expect(2 + 2) merupakan segmen yang berisi perintah yang menghasilkan nilai balikan, perintah tersebut dapat berupa fungsi ataupun perintah langsung.

! toBe(4) disebut dengan matcher, berisi nilai yang diharapkan dari sebuah perintah yang dilakukan sebelumnya. Dalam jest sendiri terdapat berbagai matchers yang dapat digunakan, misalkan:
	- toBe(x)		bahwa nilai ekspektasi yang diharapkan adalah x
	- toEqual(x)	bahwa nilai ekspektasi yang diharapkan sama dengan x
	- toBeNull()	bahwa nilai ekspektasi yang diharapkan adalah null
	- toBeTruthy()	bahwa nilai ekspektasi yang diharapkan adalah truth
	- toBeFalsy()	bahwa nilai ekspektasi yang diharapkan adalah false

// untuk membuat file hasil testing
	- npm run test -- --coverage 

! link jest cheatsheet : https://devhints.io/jest
--$$
!! contoh source code ada di folder latihan3-jest




















!! NOTE !! red
! Tiap bahasa pemrograman memiliki **hampir** tipe data primitif yang sama
! operator pangkat di javascript : **
	// contoh 2 pangkat 3 : 2**3
! constructor function tidak bisa dibuat menggunakan arrow function

! super(...) digunakan untuk memanggil constructor parent dan hanya dapat digunakan di constructor.

! super.methodName(...) digunakan untuk memanggil parent method.
! untuk return object menggunakan arrow function tanpa menggunakan kata kunci 'return' maka gunakan '()'
	// contoh : 
		const checkIsValidPhone = self => ({
		    isValid: () => console.log('valid phone', self.from)
		  });

! Metode Object.assign(target, source1, sourceN,) menyalin semua properti enumerable sendiri dari satu atau lebih objek sumber ke objek target. Ini mengembalikan objek target yang dimodifikasi.

! epoch mili-detik (dimulai dari 1 January, 1970 yang berarti 0)
! LTS merupakan kepanjangan dari Long Term Support.







## ILT 
KAK fikri merupakan kurikulum developer di Dicoding

// switch case
let keyword = 'English';
switch(keyword){
	case "value":
	console.log('welcome');
	break;
}

// for if loop
for(const arr of arrays){
	console.log(arr);
}

=== Struktur Data ===

// Object
- menyimpan data yang kompleks
- key dan value = property
- biasanya digunakan dalam format file JSON

// Array
- Mengelompokkan lebih dari satu nilai dan menempatkannya dalam satu variabel
- Disusun berdasarkan index dimulai dari 0


// Destructuring Object dan Array
- Sintaksis yang mengeluarkan nilai dari array atau properties dari sebuah objecy
- penulisan sintaksis destructuring objecy pada ES6 menggunakan object 

// Map

// Set


=== ===

=== Function Javascript ===
// declaring function
- result o/i
- parameter
- argument
- return value


// arrow function 
- untuk mempersingkat penulisan function

// variabel scope
- globaly scope
- localy scope

// closure
- merupakan fungsi yang dapat mengakses variabel di dalam lexical scope

! lexical scope adalah


! Digital wellbeing experiments



